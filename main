import pandas as pd
from math import floor
import sys

# --- Monthly withdrawal + liquidation trackers ---
WITHDRAWAL_LOG = []
LIQUIDATED_COUNT = 0
last_trade_month = None

# Redirect all print output to a log file
sys.stdout = open("trade_log4.txt", "w")

# Parameters
LOOKBACK_BARS = 20        # number of bars for recent range high/low
VOL_LOOKBACK = 20         # number of bars for average volume calculation
VOL_THRESHOLD = 2.0       # require breakout volume >= 2.0x average of last VOL_LOOKBACK bars
RISK_PER_TRADE = 2000.0    # risk per trade in USD (or in "R" units)
INITIAL_BALANCE = 100000.0
PIP_VALUE_PER_LOT = 1.0   # pip/point value per lot (for position size calc, if needed)
FEE_PER_LOT = 0.0         # assume zero or negligible fees for simplicity

# thresholds
LIQUIDATION_FLOOR = 90_000.0           # below this → liquidate
WITHDRAWAL_BASE  = INITIAL_BALANCE     # withdraw down to this at month end

# Load NAS100 CSV file
df = pd.read_csv("US100.cash_2017.csv", delimiter=";")

# Standardize column names
df.columns = ["time", "open", "high", "low", "close", "tick_volume"]

# Parse time column into datetime
df['time'] = pd.to_datetime(df['time'], format="%Y.%m.%d %H:%M")

# Sort by time just in case
df = df.sort_values('time').reset_index(drop=True)

print(df.head())

df['vol_avg'] = df['tick_volume'].rolling(window=VOL_LOOKBACK).mean().shift(1)  # average of previous VOL_LOOKBACK bars

# Performance counters and logs
ACCOUNT_BALANCE = INITIAL_BALANCE
equity_curve = [ACCOUNT_BALANCE]        # track balance over time (at trade events)
equity_time = [df['time'].iloc[0]]      # corresponding times for equity_curve points
trade_log = []                         # store trade details
count_full_tp = count_full_sl = count_partial_sl = count_skips = 0

# Trade state variables
in_trade = False
direction = None       # 'long' or 'short'
entry_price = None
entry_time = None
stop_price = None
trail_stop = None
partial_target = None
partial_hit = False

# We iterate through the DataFrame to detect signals and simulate trades
i = LOOKBACK_BARS  # start after enough bars for lookback range
while i < len(df) - 1:  # leave one bar for entry/exit processing

    curr_time = df.loc[i, "time"]

    if not in_trade:
        # Check breakout conditions on bar i (the current completed bar)
        current_close = df.loc[i, 'close']
        recent_high = df.loc[i-LOOKBACK_BARS:i-1, 'high'].max()
        recent_low  = df.loc[i-LOOKBACK_BARS:i-1, 'low'].min()
        vol_avg = df.loc[i, 'vol_avg']  # avg volume of prior VOL_LOOKBACK bars
        curr_vol = df.loc[i, 'tick_volume']
        trigger_long = False
        trigger_short = False

        # Price breakout criteria
        if current_close > recent_high:
            # potential long breakout
            # Volume confirmation
            if curr_vol >= VOL_THRESHOLD * vol_avg if pd.notna(vol_avg) else False:
                trigger_long = True
            else:
                # Price broke out upward but volume too low – skip trade
                # (We count this as a skipped signal due to lack of confirmation)
                count_skips += 1
        elif current_close < recent_low:
            # potential short breakout
            if curr_vol >= VOL_THRESHOLD * vol_avg if pd.notna(vol_avg) else False:
                trigger_short = True
            else:
                count_skips += 1

        # If a breakout signal is confirmed, initialize a new trade
        if trigger_long or trigger_short:
            in_trade = True
            direction = 'long' if trigger_long else 'short'
            # Enter at next bar's open (to simulate waiting for breakout bar to close)
            entry_time = df.loc[i+1, 'time']
            entry_price = df.loc[i+1, 'open']
            # Determine stop-loss based on recent range
            if direction == 'long':
                stop_price = recent_low  # below the support of the range
                # In case stop_price is >= entry (shouldn't normally happen if breakout above range)
                if stop_price >= entry_price:
                    in_trade = False
                    count_skips += 1
                    i += 1
                    continue
                stop_distance = entry_price - stop_price
                partial_target = entry_price + stop_distance  # +1R
            else:
                stop_price = recent_high  # above the resistance for shorts
                if stop_price <= entry_price:
                    in_trade = False
                    count_skips += 1
                    i += 1
                    continue
                stop_distance = stop_price - entry_price
                partial_target = entry_price - stop_distance  # -1R

            partial_hit = False
            # Position sizing (if needed for lot size; here mainly for logging)
            lot_size = RISK_PER_TRADE / (stop_distance * PIP_VALUE_PER_LOT)
            print(f"📥 ENTRY {direction.upper()} at {entry_time} | Price: {entry_price:.2f}, SL: {stop_price:.2f}, Risk/pos: ${RISK_PER_TRADE:.2f}")
            print(f"    Breakout from range {LOOKBACK_BARS}-bar High/Low and volume {curr_vol:.0f} (>{VOL_THRESHOLD}× avg {vol_avg:.0f})")
            print(f"    Initial lot size ~ {lot_size:.2f} for RISK_PER_TRADE ${RISK_PER_TRADE:.2f}")

            # Proceed to simulate the trade’s future bars for exits
            i += 1  # move to the first bar after entry
            continue  # go to trade management loop

    if in_trade:
        # We are in a trade, manage it
        # For convenience, get current bar values
        curr_time = df.loc[i, 'time']
        high = df.loc[i, 'high']
        low = df.loc[i, 'low']

        if not partial_hit:
            # Check if partial TP level is reached
            if direction == 'long' and high >= partial_target:
                partial_hit = True
                # Realize profit on half position at partial_target
                profit_half = RISK_PER_TRADE * 0.5  # +0.5R (half position at +1R move yields half the risk in profit)
                ACCOUNT_BALANCE += profit_half
                # Move trailing stop to break-even (entry price) for remaining half
                trail_stop = entry_price
                print(f"    ✅ Partial TP hit at {curr_time} - closed 50% at +1R. +${profit_half:.2f} realized, stop moved to {trail_stop:.2f}")
                # Record equity after partial profit
                equity_time.append(curr_time)
                equity_curve.append(ACCOUNT_BALANCE)
            elif direction == 'short' and low <= partial_target:
                partial_hit = True
                profit_half = RISK_PER_TRADE * 0.5
                ACCOUNT_BALANCE += profit_half
                trail_stop = entry_price
                print(f"    ✅ Partial TP hit at {curr_time} - closed 50% at +1R. +${profit_half:.2f} realized, stop moved to {trail_stop:.2f}")
                equity_time.append(curr_time)
                equity_curve.append(ACCOUNT_BALANCE)

        # Update trailing stop if partial was hit and price moved further
        if partial_hit:
            # Determine new trailing stop based on 1R increments beyond the highest profit seen
            if direction == 'long':
                # calculate how many R profit currently (above entry)
                profit_r = (high - entry_price) / (entry_price - stop_price)  # current profit in R units
                # If price exceeds the current trail stop level by another 1R, raise the stop
                if profit_r >= 1 + 1e-9:  # ensure at least 1R profit exists (should be true if partial_hit)
                    # locked_in_r represents how many R we have locked so far (trail_stop relative to entry)
                    locked_in_r = (trail_stop - entry_price) / (entry_price - stop_price) if trail_stop is not None else 0
                    # If new profit level crosses locked_in_r + 1, advance trailing stop
                    if profit_r >= locked_in_r + 2:  # price reached next 1R beyond last lock
                        new_locked = floor(profit_r) - 1  # lock profit one R less than whole R achieved
                        new_trail = entry_price + new_locked * (entry_price - stop_price)
                        if trail_stop is None or new_trail > trail_stop:
                            trail_stop = new_trail
                            print(f"    🔄 Trailing stop moved up to {trail_stop:.2f} (+{new_locked}R locked)")
            else:  # short
                profit_r = (entry_price - low) / (stop_price - entry_price)  # how many R in profit
                if profit_r >= 1 + 1e-9:
                    locked_in_r = (entry_price - trail_stop) / (stop_price - entry_price) if trail_stop is not None else 0
                    if profit_r >= locked_in_r + 2:
                        new_locked = floor(profit_r) - 1
                        new_trail = entry_price - new_locked * (stop_price - entry_price)
                        if trail_stop is None or new_trail < trail_stop:
                            trail_stop = new_trail
                            print(f"    🔄 Trailing stop moved {'down' if direction=='short' else 'up'} to {trail_stop:.2f} (+{new_locked}R locked)")

        # Check stop-loss (or trailing stop) hit conditions
        stop_hit = False
        # Use appropriate stop level: if partial not hit, use initial stop_price; if partial hit, use trail_stop (which is at least entry)
        if direction == 'long':
            active_stop = trail_stop if partial_hit else stop_price
            if low <= active_stop:
                stop_hit = True
        else:  # short
            active_stop = trail_stop if partial_hit else stop_price
            if high >= active_stop:
                stop_hit = True

        if stop_hit:
            exit_time = curr_time
            exit_price = active_stop  # assume we exit at the stop price
            # Determine outcome category and P&L
            if not partial_hit:
                # Full stop without any partial profit
                outcome = "FULL_SL"
                pnl = -RISK_PER_TRADE  # lost 1R
                count_full_sl += 1
                print(f"    ❌ Stop-loss hit at {exit_time} → -${RISK_PER_TRADE:.2f} (Full SL)")
                ACCOUNT_BALANCE += pnl
            else:
                # Partial was taken, now stop on remainder
                # If trail_stop is at entry (break-even) or very close, remainder P&L ≈ 0
                # If trail_stop trailed into profit, remainder P&L positive
                remainder_profit = 0.0
                if direction == 'long':
                    remainder_profit = (active_stop - entry_price) * (lot_size / 2) * PIP_VALUE_PER_LOT
                    # lot_size/2 because half position remaining
                else:
                    remainder_profit = (entry_price - active_stop) * (lot_size / 2) * PIP_VALUE_PER_LOT
                pnl = remainder_profit  # profit (or 0) from remainder; partial already added to balance
                # (Note: partial profit was already added to balance and equity_curve)
                ACCOUNT_BALANCE += pnl
                print(f"📊 Account balance after trade: ${ACCOUNT_BALANCE:,.2f}")

                if pnl > 1e-9:
                    outcome = "FULL_TP"  # remainder exited with profit -> consider as full TP outcome
                    count_full_tp += 1
                    print(f"    🏁 Trailing stop hit at {exit_time}, locking in remaining profit. Trade outcome: Full TP")
                else:
                    outcome = "PARTIAL_SL"
                    count_partial_sl += 1
                    print(f"    🟡 Break-even stop hit at {exit_time} after partial. Trade outcome: Partial TP then SL")
            # Log trade details
            trade_log.append({
                "entry_time": entry_time,
                "exit_time": exit_time,
                "direction": "BUY" if direction == "long" else "SELL",
                "entry_price": entry_price,
                "exit_price": exit_price,
                "stop_price": stop_price,
                "partial_price": partial_target,
                "outcome": outcome,
                "net_PnL": ACCOUNT_BALANCE - INITIAL_BALANCE  # current net profit from start (or calculate per trade separately)
            })
            # Record equity after trade closure
            equity_time.append(exit_time)
            equity_curve.append(ACCOUNT_BALANCE)
            # Reset trade state
            in_trade = False
            direction = None
            entry_price = entry_time = None
            stop_price = trail_stop = partial_target = None
            partial_hit = False
            # After closing a trade, we do not increment i here, to re-evaluate any new signal on the same bar (though typically unlikely)
            # Instead, allow loop to continue and increment i at end.
    # If no stop hit and trade still open, or if no trade at all, just move to next bar
    # ---- month rollover & liquidation checks ----
    current_month = curr_time.strftime("%Y-%m")

    if last_trade_month is None:
        last_trade_month = current_month

    # month just ended
    elif current_month != last_trade_month:
        # withdrawal check
        if ACCOUNT_BALANCE > INITIAL_BALANCE:
            withdrawn = ACCOUNT_BALANCE - INITIAL_BALANCE
            WITHDRAWAL_LOG.append((last_trade_month, withdrawn))
            print(f"💸 Withdrawal of ${withdrawn:,.2f} for {last_trade_month} (balance reset to {INITIAL_BALANCE})")
            ACCOUNT_BALANCE = INITIAL_BALANCE

        # liquidation check (if balance fell below floor during that month)
        if ACCOUNT_BALANCE < 90_000:
            LIQUIDATED_COUNT += 1
            print(f"⚠️ Account liquidated in {last_trade_month}, reset to {INITIAL_BALANCE}")

        # move into new month
        last_trade_month = current_month

    i += 1

# After loop, if a trade is still open at the very end of data, close it at last price
if in_trade:
    final_time = df['time'].iloc[-1]
    final_price = df['close'].iloc[-1]
    # If trade open and partial not hit, count as stopped (since we exit at end)
    if not partial_hit:
        outcome = "FULL_SL"  # treat as stop (could not reach target before data end)
        pnl = -RISK_PER_TRADE
        count_full_sl += 1
    else:
        # If partial taken, close remainder at final price
        if direction == 'long':
            remainder_profit = (final_price - entry_price) * (lot_size / 2) * PIP_VALUE_PER_LOT
        else:
            remainder_profit = (entry_price - final_price) * (lot_size / 2) * PIP_VALUE_PER_LOT
        pnl = remainder_profit
        ACCOUNT_BALANCE += pnl
        if pnl > 1e-9:
            outcome = "FULL_TP"
            count_full_tp += 1
        else:
            outcome = "PARTIAL_SL"
            count_partial_sl += 1
    trade_log.append({
        "entry_time": entry_time,
        "exit_time": final_time,
        "direction": "BUY" if direction == "long" else "SELL",
        "entry_price": entry_price,
        "exit_price": final_price,
        "stop_price": stop_price,
        "partial_price": partial_target,
        "outcome": outcome,
        "net_PnL": ACCOUNT_BALANCE - INITIAL_BALANCE
    })
    equity_time.append(final_time)
    equity_curve.append(ACCOUNT_BALANCE)
    print(f"    ⚠️ Trade open at end of data. Closing at {final_time} price {final_price:.2f}. Outcome: {outcome}")
    in_trade = False

# Performance Summary
total_trades = count_full_tp + count_full_sl + count_partial_sl
win_rate = 0.0
if total_trades > 0:
    # consider full_tp and partial_sl as "wins" (both yielded net gain), full_sl as loss
    wins = count_full_tp + count_partial_sl
    win_rate = wins / total_trades * 100
net_profit = ACCOUNT_BALANCE - INITIAL_BALANCE

print("\n==== Strategy Performance Summary ====")
print(f"Period tested: {df['time'].iloc[0]} to {df['time'].iloc[-1]}")
print(f"Total Trades: {total_trades}")
print(f"Full TP outcomes: {count_full_tp}")
print(f"Full SL outcomes: {count_full_sl}")
print(f"Partial TP then SL outcomes: {count_partial_sl}")
print(f"Skipped signals due to low volume: {count_skips}")
print(f"Win rate (incl. partial wins): {win_rate:.1f}%")
print(f"Net Profit: {net_profit:.2f} ({net_profit/RISK_PER_TRADE:.1f}R)")
print("======================================")

# Summary
print("\n==== Strategy Performance Summary ====")
print(f"Period tested: {df['time'].iloc[0]} to {df['time'].iloc[-1]}")
print(f"Net Profit: {ACCOUNT_BALANCE - INITIAL_BALANCE:.2f}")

print("\n💸 Withdrawals:")
if WITHDRAWAL_LOG:
    for month, amount in WITHDRAWAL_LOG:
        print(f" {month}: ${amount:,.2f}")
else:
    print(" None")

print(f"\n🔁 Total liquidated accounts: {LIQUIDATED_COUNT}")


# Convert equity curve to DataFrame for potential plotting or output
equity_df = pd.DataFrame({'time': equity_time, 'balance': equity_curve})
# equity_df.to_csv("equity_curve.csv", index=False)  # if saving needed

# (Optional) Plot equity curve using matplotlib or plotly
import matplotlib.pyplot as plt
plt.figure(figsize=(8,4))
plt.plot(equity_df['time'], equity_df['balance'], label="Equity Curve")
plt.title("NAS100 Breakout Strategy Equity Curve")
plt.xlabel("Time")
plt.ylabel("Account Balance")
plt.legend()
plt.tight_layout()
plt.show()
